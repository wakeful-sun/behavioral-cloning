from os import path, makedirs
import csv
import cv2
from sklearn.utils import shuffle
from math import floor
import pandas as pd
import matplotlib.image as mpimg


class DataContainer:

    def __init__(self, validation_split=0, data_folder_path="../captured_data"):
        if validation_split < 0 or validation_split >= 1:
            raise Exception("validation_set_len parameter should be in range [0..1]")

        data_path = path.join(path.dirname(__file__), data_folder_path)
        with open(path.join(data_path, "driving_log.csv")) as f:
            driving_log = csv.reader(f, delimiter=",")
            data_frame_factory = DataFrameFactory(data_path)
            data = [data_frame_factory.create(line) for line in driving_log]

        validation_set_len = floor(len(data) * validation_split)
        shuffle(data)

        self.training_data = DataProvider(data[validation_set_len:])
        self.validation_data = DataProvider(data[:validation_set_len])
        self.initial_len = len(data)

    @property
    def training(self):
        return self.training_data

    @property
    def validation(self):
        return self.validation_data

    def get_summary_dict(self, batch_size):
        t_data_summary = self.training_data.get_summary_dict(batch_size)
        v_data_summary = self.validation_data.get_summary_dict(batch_size)

        return {
            "training_data": t_data_summary,
            "validation_data": v_data_summary,
            "generated_by_augmentation": self.validation.count + self.training.count - self.initial_len
        }

    def print_summary(self, batch_size):
        summary = self.get_summary_dict(batch_size)
        t_data_summary, v_data_summary = summary["training_data"], summary["validation_data"]
        t_stat = t_data_summary["angle_statistics"]
        v_stat = v_data_summary["angle_statistics"]
        t_data_count = t_data_summary["count"]
        v_data_count = v_data_summary["count"]

        print("*" * 80)
        print(" Training items                    : {}".format(t_data_count))
        print(" Validation items                  : {}".format(v_data_count))
        print(" Unique training steering angles   : {}".format(len(t_stat["angle"])))
        print(" Unique validation steering angles : {}".format(len(v_stat["angle"])))
        print(" Generated by augmentation         : {}".format(summary["generated_by_augmentation"]))
        print(" Top 10 training steering angles:")
        for i in range(0, 10):
            angle, count = t_stat["angle"][i], t_stat["size"][i]
            print("     Steering angle {:.5f} : {:.2f}%".format(angle, (count*100)/t_data_count))
        print("*" * 80)


class DataProvider:

    def __init__(self, data_frames):
        self.data_frames = data_frames

    @property
    def count(self):
        return len(self.data_frames)

    def get_range(self, start_index, stop_index):
        batch = self.data_frames[start_index:stop_index]

        batch_data = [], []
        for item in batch:
            image, angle = item.get_training_data()
            batch_data[0].append(image)
            batch_data[1].append(angle)

        return batch_data

    def shuffle(self, a=None, b=None):
        shuffle(self.data_frames)

    def apply_augmentation(self, augmentation_func, filter_func=None):
        if filter_func is None:
            filter_func = lambda x: True
        if not callable(augmentation_func):
            raise Exception("augmentation_func expected to be function, but was '{}'".format(type(augmentation_func)))
        if not callable(filter_func):
            raise Exception("filter_func expected to be function, but was '{}'".format(type(filter_func)))

        def create_frame(original_frame):
            frame = original_frame.create_copy()
            frame.add_augmentation_func(augmentation_func)
            return frame

        filtered_frames = filter(filter_func, self.data_frames)
        extra_frames_map = list(map(create_frame, filtered_frames))
        self.data_frames = self.data_frames + extra_frames_map
        shuffle(self.data_frames)

    def drop_zero_angle_items(self, rate):
        zero_angle_frames = list(filter(lambda x: x.steering_angle == 0, self.data_frames))
        non_zero_angle_frames = list(filter(lambda x: x.steering_angle != 0, self.data_frames))
        shuffle(zero_angle_frames)
        items_to_drop = int(len(zero_angle_frames) * rate)
        self.data_frames = list(non_zero_angle_frames) + list(zero_angle_frames[items_to_drop:])

    def save_top_images(self, output_folder, sub_folder, images_count=20):
        directory = path.join(output_folder, sub_folder)
        if not path.exists(directory):
            makedirs(directory)

        for i in range(0, images_count+1):
            image, angle = self.data_frames[i].get_training_data()
            brg_image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
            image_path = path.join(directory, "0_[{}].png".format(angle))
            cv2.imwrite(image_path, brg_image)

    def get_summary_dict(self, batch_size):
        steering_angles = [frame.steering_angle for frame in self.data_frames]
        initial_len = len(steering_angles)
        df = pd.DataFrame({"angle": steering_angles})
        steering_angles_statistics = df.groupby("angle")\
            .size()\
            .reset_index(name="size")\
            .sort_values(["size"], ascending=False)\
            .to_dict(orient="list")

        data_summary = {
            "angle_statistics": steering_angles_statistics,
            "count": (initial_len // batch_size) * batch_size
        }
        return data_summary


class DataFrameFactory:

    def __init__(self, data_folder_path):
        self.data_folder_path = data_folder_path

    def create(self, line):
        center = self._fit_image_path(self.data_folder_path, line[0])
        left = self._fit_image_path(self.data_folder_path, line[1])
        right = self._fit_image_path(self.data_folder_path, line[2])
        angle = float(line[3])
        return DataFrame(center, left, right, angle)

    @staticmethod
    def _fit_image_path(data_folder_path, original_path):
        image_in_folder = "/".join(original_path.split("\\")[-2:])
        image_path = path.join(data_folder_path, image_in_folder)
        return path.normpath(image_path)


class DataFrame:

    def __init__(self, center_image_path, left_image_path, right_image_path, steering_angle, f_array=None):
        self.im_path_center = center_image_path
        self.im_path_left = left_image_path
        self.im_path_right = right_image_path
        self.angle = steering_angle
        if f_array is None:
            self.augmentation_functions = []
        else:
            self.augmentation_functions = f_array

    def create_copy(self):
        data_frame_copy = DataFrame(
            self.im_path_center,
            self.im_path_left,
            self.im_path_right,
            self.angle,
            self.augmentation_functions)
        return data_frame_copy

    @property
    def steering_angle(self):
        return self.angle

    def add_augmentation_func(self, f):
        modify_image_func, self.angle = f(self.angle)
        self.augmentation_functions.append(modify_image_func)

    def get_training_data(self):
        bgr_image = cv2.imread(self.im_path_center)
        rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)

        image = rgb_image

        for modify_image_func in self.augmentation_functions:
            if callable(modify_image_func):
                image = modify_image_func(image)

        return image, self.angle
