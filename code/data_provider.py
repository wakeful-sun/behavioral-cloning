from os import path
import csv
import cv2
from sklearn.utils import shuffle
from math import floor
import pandas as pd
import matplotlib.image as mpimg


class DataContainer:

    def __init__(self, validation_split=0, data_folder_path="../captured_data"):
        if validation_split < 0 or validation_split >= 1:
            raise Exception("validation_set_len parameter should be in range [0..1]")

        data_path = path.join(path.dirname(__file__), data_folder_path)
        with open(path.join(data_path, "driving_log.csv")) as f:
            driving_log = csv.reader(f, delimiter=",")
            data_frame_factory = DataFrameFactory(data_path)
            data = [data_frame_factory.create(line) for line in driving_log]

        validation_set_len = floor(len(data) * validation_split)
        shuffle(data)

        self.training_data = DataProvider(data[validation_set_len:])
        self.validation_data = DataProvider(data[:validation_set_len])
        self.initial_len = len(data)

    @property
    def training(self):
        return self.training_data

    @property
    def validation(self):
        return self.validation_data

    def get_summary_dict(self, batch_size):
        t_data_summary = self.training_data.get_summary_dict(batch_size)
        v_data_summary = self.validation_data.get_summary_dict(batch_size)

        return {
            "training_data": t_data_summary,
            "validation_data": v_data_summary,
            "generated_by_augmentation": self.validation.count + self.training.count - self.initial_len
        }

    def print_summary(self, batch_size):
        summary = self.get_summary_dict(batch_size)
        t_data_summary, v_data_summary = summary["training_data"], summary["validation_data"]
        t_stat = t_data_summary["angle_statistics"]
        v_stat = t_data_summary["angle_statistics"]
        t_data_count = t_data_summary["count"]
        v_data_count = v_data_summary["count"]

        print("*" * 80)
        print(" Training items                    : {}".format(t_data_count))
        print(" Validation items                  : {}".format(v_data_count))
        print(" Unique training steering angles   : {}".format(len(t_stat["angle"])))
        print(" Unique validation steering angles : {}".format(len(v_stat["angle"])))
        print(" Generated by augmentation         : {}".format(summary["generated_by_augmentation"]))
        print(" Top 10 training steering angles:")
        for i in range(0, 10):
            angle, count = t_stat["angle"][i], t_stat["size"][i]
            print("     Steering angle {:.5f} : {:.2f}%".format(angle, (count*100)/t_data_count))
        print("*" * 80)


class DataProvider:

    def __init__(self, data_frames):
        self.data_frames = data_frames

    @property
    def count(self):
        return len(self.data_frames)

    def get_range(self, start_index, stop_index):
        batch = self.data_frames[start_index:stop_index]

        batch_data = [], []
        for item in batch:
            image, angle = item.get_training_data()
            batch_data[0].append(image)
            batch_data[1].append(angle)

        return batch_data

    def shuffle(self, a=None, b=None):
        shuffle(self.data_frames)

    def apply_augmentation(self, augmentation_func, apply_rate=1):
        if not callable(augmentation_func):
            raise Exception("augmentation_func expected to be function, but was '{}'".format(type(augmentation_func)))

        def create_frame(original_frame):
            frame = original_frame.create_copy()
            frame.augmentation_functions.append(augmentation_func)
            return frame

        extra_frames_map = map(create_frame, self.data_frames[:self.count*apply_rate])
        self.data_frames = self.data_frames + list(extra_frames_map)
        shuffle(self.data_frames)

    def get_summary_dict(self, batch_size):
        steering_angles = [frame.original_steering_angle for frame in self.data_frames]
        initial_len = len(steering_angles)
        df = pd.DataFrame({"angle": steering_angles})
        steering_angles_statistics = df.groupby("angle")\
            .size()\
            .reset_index(name="size")\
            .sort_values(["size"], ascending=False)\
            .to_dict(orient="list")

        data_summary = {
            "angle_statistics": steering_angles_statistics,
            "count": (initial_len // batch_size) * batch_size
        }
        return data_summary


class DataFrameFactory:

    def __init__(self, data_folder_path):
        self.data_folder_path = data_folder_path

    def create(self, line):
        center = self._fit_image_path(self.data_folder_path, line[0])
        left = self._fit_image_path(self.data_folder_path, line[1])
        right = self._fit_image_path(self.data_folder_path, line[2])
        angle = float(line[3])
        return DataFrame(center, left, right, angle)

    @staticmethod
    def _fit_image_path(data_folder_path, original_path):
        image_in_folder = "/".join(original_path.split("\\")[-2:])
        image_path = path.join(data_folder_path, image_in_folder)
        return path.normpath(image_path)


class DataFrame:

    def __init__(self, center_image_path, left_image_path, right_image_path, steering_angle):
        self.im_path_center = center_image_path
        self.im_path_left = left_image_path
        self.im_path_right = right_image_path
        self.steering_angle = steering_angle
        self.registered_augmentation_functions = []

    def create_copy(self):
        data_frame_copy = DataFrame(self.im_path_center, self.im_path_left, self.im_path_right, self.steering_angle)
        for func in self.augmentation_functions:
            data_frame_copy.augmentation_functions.append(func)
        return data_frame_copy

    @property
    def augmentation_functions(self):
        return self.registered_augmentation_functions

    @property
    def original_steering_angle(self):
        return self.steering_angle

    def get_training_data(self):
        bgr_image = cv2.imread(self.im_path_center)
        rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)

        training_data = rgb_image, self.steering_angle

        for func in self.augmentation_functions:
            if callable(func):
                training_data = func(training_data)

        return training_data
