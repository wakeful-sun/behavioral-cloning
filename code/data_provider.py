from os import path, makedirs
import csv
import cv2
from sklearn.utils import shuffle
from math import floor
import pandas as pd
import numpy as np


class DataContainer:

    def __init__(self, validation_split=0, data_folder_path="../captured_data"):
        assert validation_split > 0 and validation_split <= 1, "validation_set_len parameter should be in range [0..1]"

        data_path = path.join(path.dirname(__file__), data_folder_path)
        with open(path.join(data_path, "driving_log.csv")) as f:
            driving_log = csv.reader(f, delimiter=",")
            data_frame_factory = DataFrameFactory(data_path)
            data = [data_frame_factory.create_center(line) for line in driving_log]

        data = shuffle(data)
        validation_set_len = floor(len(data) * validation_split)

        self.training_data = DataProvider(data[validation_set_len:])
        self.validation_data = DataProvider(data[:validation_set_len])
        self.initial_len = len(data)

    @property
    def training(self):
        return self.training_data

    @property
    def validation(self):
        return self.validation_data

    def get_summary_dict(self, batch_size):
        t_data_summary = self.training_data.get_summary_dict(batch_size)
        v_data_summary = self.validation_data.get_summary_dict(batch_size)

        return {
            "training_data": t_data_summary,
            "validation_data": v_data_summary,
            "generated_by_augmentation": self.validation.count + self.training.count - self.initial_len
        }

    def print_summary(self, batch_size):
        summary = self.get_summary_dict(batch_size)
        t_data_summary, v_data_summary = summary["training_data"], summary["validation_data"]
        t_stat = t_data_summary["angle_statistics"]
        v_stat = v_data_summary["angle_statistics"]
        t_data_count = t_data_summary["count"]
        v_data_count = v_data_summary["count"]

        print("*" * 80)
        print(" Training items                    : {}".format(t_data_count))
        print(" Validation items                  : {}".format(v_data_count))
        print(" Unique training steering angles   : {}".format(len(t_stat["angle"])))
        print(" Unique validation steering angles : {}".format(len(v_stat["angle"])))
        print(" Generated by augmentation         : {}".format(summary["generated_by_augmentation"]))
        print(" Top 10 training steering angles:")
        for i in range(0, 10):
            angle, count = t_stat["angle"][i], t_stat["size"][i]
            print("     Steering angle {:.5f} : {:.2f}%".format(angle, (count*100)/t_data_count))
        print("*" * 80)


class DataProvider:

    def __init__(self, data_frames):
        self.data_frames = data_frames

    @property
    def count(self):
        return len(self.data_frames)

    def get_range(self, start_index, stop_index):
        batch = self.data_frames[start_index:stop_index]

        batch_data = [], []
        for item in batch:
            image, angle = item.get_training_data()
            batch_data[0].append(image)
            batch_data[1].append(angle)

        return batch_data

    def shuffle(self, a=None, b=None):
        self.data_frames = shuffle(self.data_frames)

    def apply_augmentation(self, augmentation_func, filter_func=None):
        assert callable(augmentation_func), "augmentation_func expected to be function"

        def create_frame(original_frame):
            frame = original_frame.create_copy()
            frame.add_augmentation_func(augmentation_func)
            return frame

        if filter_func is None:
            extra_frames = filter(filter_func, self.data_frames)
        else:
            extra_frames = self.data_frames[:]

        extra_frames_map = map(create_frame, extra_frames)
        self.data_frames = self.data_frames + list(extra_frames_map)
        self.shuffle()

    def save_top_images(self, output_folder, sub_folder, images_count=20):
        directory = path.join(output_folder, sub_folder)
        if not path.exists(directory):
            makedirs(directory)

        for i in range(0, images_count+1):
            image, angle = self.data_frames[i].get_training_data()
            brg_image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
            image_path = path.join(directory, "0_[{}].png".format(angle))
            cv2.imwrite(image_path, brg_image)

    def get_summary_dict(self, batch_size):
        steering_angles = [frame.steering_angle for frame in self.data_frames]
        initial_len = len(steering_angles)
        df = pd.DataFrame({"angle": steering_angles})
        steering_angles_statistics = df.groupby("angle")\
            .size()\
            .reset_index(name="size")\
            .sort_values(["size"], ascending=False)\
            .to_dict(orient="list")

        data_summary = {
            "angle_statistics": steering_angles_statistics,
            "count": (initial_len // batch_size) * batch_size
        }
        return data_summary


class DataFrameFactory:

    def __init__(self, data_folder_path):
        self.data_folder_path = data_folder_path

    def create_center(self, line):
        center_image_path = self._fit_image_path(self.data_folder_path, line[0])
        angle = float(line[3])
        return DataFrame(center_image_path, angle)

    @staticmethod
    def _fit_image_path(data_folder_path, original_path):
        image_in_folder = "/".join(original_path.split("\\")[-2:])
        image_path = path.join(data_folder_path, image_in_folder)
        return path.normpath(image_path)


class DataFrame:

    def __init__(self, image_path, steering_angle, f_array=None):
        self.im_path = image_path
        self.angle = steering_angle
        if f_array is None:
            self.augmentation_functions = []
        else:
            self.augmentation_functions = f_array

    def create_copy(self):
        return DataFrame(self.im_path, self.angle, list(self.augmentation_functions))

    @property
    def steering_angle(self):
        empty_image = np.array([[[]]], dtype=np.uint8)
        angle = self.angle

        for f in self.augmentation_functions:
            _, angle = f(empty_image, angle)

        return angle

    def add_augmentation_func(self, f):
        self.augmentation_functions.append(f)

    def get_training_data(self):
        bgr_image = cv2.imread(self.im_path)
        rgb_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2RGB)

        image, angle = rgb_image, self.angle

        for f in self.augmentation_functions:
            image, angle = f(image, angle)

        return image, angle
